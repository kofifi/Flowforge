import {
  BaseEdge,
  BezierEdge,
  ConnectionLineType,
  ConnectionMode,
  EdgeLabelRenderer,
  EdgeText$1,
  Handle$1,
  MarkerType,
  PanOnScrollMode,
  Panel,
  Position,
  ReactFlow,
  ReactFlowProvider,
  SelectionMode,
  SimpleBezierEdge,
  SmoothStepEdge,
  StepEdge,
  StraightEdge,
  addEdge,
  applyEdgeChanges,
  applyNodeChanges,
  boxToRect,
  cc,
  clamp,
  drag_default,
  getBezierPath,
  getBoundsOfRects,
  getConnectedEdges,
  getIncomers,
  getMarkerEnd,
  getNodePositionWithOrigin,
  getNodesBounds,
  getOutgoers,
  getRectOfNodes,
  getSimpleBezierPath,
  getSmoothStepPath,
  getStraightPath,
  getTransformForBounds,
  getViewportForBounds,
  handleParentExpand,
  identity,
  internalsSymbol,
  isEdge,
  isNode,
  pointer_default,
  reconnectEdge,
  rectToBox,
  select_default,
  shallow$1,
  updateEdge,
  useEdges,
  useEdgesState,
  useGetPointerPosition,
  useKeyPress,
  useNodeId,
  useNodes,
  useNodesInitialized,
  useNodesState,
  useOnSelectionChange,
  useOnViewportChange,
  useReactFlow,
  useStore,
  useStoreApi,
  useUpdateNodeInternals,
  useViewport,
  zoom_default
} from "./chunk-BXUZSFW4.js";
import "./chunk-6VEMZQB5.js";
import {
  require_react_dom
} from "./chunk-6WSUK3PT.js";
import {
  __toESM,
  require_react
} from "./chunk-T5ZXRJCU.js";

// node_modules/@reactflow/minimap/dist/esm/index.mjs
var import_react = __toESM(require_react(), 1);
var MiniMapNode = ({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, onClick, selected }) => {
  const { background, backgroundColor } = style || {};
  const fill = color || background || backgroundColor;
  return import_react.default.createElement("rect", { className: cc(["react-flow__minimap-node", { selected }, className]), x, y, rx: borderRadius, ry: borderRadius, width, height, fill, stroke: strokeColor, strokeWidth, shapeRendering, onClick: onClick ? (event) => onClick(event, id) : void 0 });
};
MiniMapNode.displayName = "MiniMapNode";
var MiniMapNode$1 = (0, import_react.memo)(MiniMapNode);
var selector$1 = (s) => s.nodeOrigin;
var selectorNodes = (s) => s.getNodes().filter((node) => !node.hidden && node.width && node.height);
var getAttrFunction = (func) => func instanceof Function ? func : () => func;
function MiniMapNodes({
  nodeStrokeColor = "transparent",
  nodeColor = "#e2e2e2",
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth = 2,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent: NodeComponent = MiniMapNode$1,
  onClick
}) {
  const nodes = useStore(selectorNodes, shallow$1);
  const nodeOrigin = useStore(selector$1);
  const nodeColorFunc = getAttrFunction(nodeColor);
  const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);
  const nodeClassNameFunc = getAttrFunction(nodeClassName);
  const shapeRendering = typeof window === "undefined" || !!window.chrome ? "crispEdges" : "geometricPrecision";
  return import_react.default.createElement(import_react.default.Fragment, null, nodes.map((node) => {
    const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;
    return import_react.default.createElement(NodeComponent, { key: node.id, x, y, width: node.width, height: node.height, style: node.style, selected: node.selected, className: nodeClassNameFunc(node), color: nodeColorFunc(node), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node), strokeWidth: nodeStrokeWidth, shapeRendering, onClick, id: node.id });
  }));
}
var MiniMapNodes$1 = (0, import_react.memo)(MiniMapNodes);
var defaultWidth = 200;
var defaultHeight = 150;
var selector = (s) => {
  const nodes = s.getNodes();
  const viewBB = {
    x: -s.transform[0] / s.transform[2],
    y: -s.transform[1] / s.transform[2],
    width: s.width / s.transform[2],
    height: s.height / s.transform[2]
  };
  return {
    viewBB,
    boundingRect: nodes.length > 0 ? getBoundsOfRects(getNodesBounds(nodes, s.nodeOrigin), viewBB) : viewBB,
    rfId: s.rfId
  };
};
var ARIA_LABEL_KEY = "react-flow__minimap-desc";
function MiniMap({
  style,
  className,
  nodeStrokeColor = "transparent",
  nodeColor = "#e2e2e2",
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth = 2,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent,
  maskColor = "rgb(240, 240, 240, 0.6)",
  maskStrokeColor = "none",
  maskStrokeWidth = 1,
  position = "bottom-right",
  onClick,
  onNodeClick,
  pannable = false,
  zoomable = false,
  ariaLabel = "React Flow mini map",
  inversePan = false,
  zoomStep = 10,
  offsetScale = 5
}) {
  const store = useStoreApi();
  const svg = (0, import_react.useRef)(null);
  const { boundingRect, viewBB, rfId } = useStore(selector, shallow$1);
  const elementWidth = (style == null ? void 0 : style.width) ?? defaultWidth;
  const elementHeight = (style == null ? void 0 : style.height) ?? defaultHeight;
  const scaledWidth = boundingRect.width / elementWidth;
  const scaledHeight = boundingRect.height / elementHeight;
  const viewScale = Math.max(scaledWidth, scaledHeight);
  const viewWidth = viewScale * elementWidth;
  const viewHeight = viewScale * elementHeight;
  const offset = offsetScale * viewScale;
  const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;
  const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;
  const width = viewWidth + offset * 2;
  const height = viewHeight + offset * 2;
  const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;
  const viewScaleRef = (0, import_react.useRef)(0);
  viewScaleRef.current = viewScale;
  (0, import_react.useEffect)(() => {
    if (svg.current) {
      const selection = select_default(svg.current);
      const zoomHandler = (event) => {
        const { transform, d3Selection, d3Zoom } = store.getState();
        if (event.sourceEvent.type !== "wheel" || !d3Selection || !d3Zoom) {
          return;
        }
        const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep;
        const zoom = transform[2] * Math.pow(2, pinchDelta);
        d3Zoom.scaleTo(d3Selection, zoom);
      };
      const panHandler = (event) => {
        const { transform, d3Selection, d3Zoom, translateExtent, width: width2, height: height2 } = store.getState();
        if (event.sourceEvent.type !== "mousemove" || !d3Selection || !d3Zoom) {
          return;
        }
        const moveScale = viewScaleRef.current * Math.max(1, transform[2]) * (inversePan ? -1 : 1);
        const position2 = {
          x: transform[0] - event.sourceEvent.movementX * moveScale,
          y: transform[1] - event.sourceEvent.movementY * moveScale
        };
        const extent = [
          [0, 0],
          [width2, height2]
        ];
        const nextTransform = identity.translate(position2.x, position2.y).scale(transform[2]);
        const constrainedTransform = d3Zoom.constrain()(nextTransform, extent, translateExtent);
        d3Zoom.transform(d3Selection, constrainedTransform);
      };
      const zoomAndPanHandler = zoom_default().on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
      selection.call(zoomAndPanHandler);
      return () => {
        selection.on("zoom", null);
      };
    }
  }, [pannable, zoomable, inversePan, zoomStep]);
  const onSvgClick = onClick ? (event) => {
    const rfCoord = pointer_default(event);
    onClick(event, { x: rfCoord[0], y: rfCoord[1] });
  } : void 0;
  const onSvgNodeClick = onNodeClick ? (event, nodeId) => {
    const node = store.getState().nodeInternals.get(nodeId);
    onNodeClick(event, node);
  } : void 0;
  return import_react.default.createElement(
    Panel,
    { position, style, className: cc(["react-flow__minimap", className]), "data-testid": "rf__minimap" },
    import_react.default.createElement(
      "svg",
      { width: elementWidth, height: elementHeight, viewBox: `${x} ${y} ${width} ${height}`, role: "img", "aria-labelledby": labelledBy, ref: svg, onClick: onSvgClick },
      ariaLabel && import_react.default.createElement("title", { id: labelledBy }, ariaLabel),
      import_react.default.createElement(MiniMapNodes$1, { onClick: onSvgNodeClick, nodeColor, nodeStrokeColor, nodeBorderRadius, nodeClassName, nodeStrokeWidth, nodeComponent }),
      import_react.default.createElement("path", { className: "react-flow__minimap-mask", d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fill: maskColor, fillRule: "evenodd", stroke: maskStrokeColor, strokeWidth: maskStrokeWidth, pointerEvents: "none" })
    )
  );
}
MiniMap.displayName = "MiniMap";
var MiniMap$1 = (0, import_react.memo)(MiniMap);

// node_modules/@reactflow/controls/dist/esm/index.mjs
var import_react2 = __toESM(require_react(), 1);
function PlusIcon() {
  return import_react2.default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32" },
    import_react2.default.createElement("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" })
  );
}
function MinusIcon() {
  return import_react2.default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5" },
    import_react2.default.createElement("path", { d: "M0 0h32v4.2H0z" })
  );
}
function FitViewIcon() {
  return import_react2.default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30" },
    import_react2.default.createElement("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" })
  );
}
function LockIcon() {
  return import_react2.default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
    import_react2.default.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" })
  );
}
function UnlockIcon() {
  return import_react2.default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
    import_react2.default.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" })
  );
}
var ControlButton = ({ children, className, ...rest }) => import_react2.default.createElement("button", { type: "button", className: cc(["react-flow__controls-button", className]), ...rest }, children);
ControlButton.displayName = "ControlButton";
var selector2 = (s) => ({
  isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,
  minZoomReached: s.transform[2] <= s.minZoom,
  maxZoomReached: s.transform[2] >= s.maxZoom
});
var Controls = ({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = "bottom-left" }) => {
  const store = useStoreApi();
  const [isVisible, setIsVisible] = (0, import_react2.useState)(false);
  const { isInteractive, minZoomReached, maxZoomReached } = useStore(selector2, shallow$1);
  const { zoomIn, zoomOut, fitView } = useReactFlow();
  (0, import_react2.useEffect)(() => {
    setIsVisible(true);
  }, []);
  if (!isVisible) {
    return null;
  }
  const onZoomInHandler = () => {
    zoomIn();
    onZoomIn == null ? void 0 : onZoomIn();
  };
  const onZoomOutHandler = () => {
    zoomOut();
    onZoomOut == null ? void 0 : onZoomOut();
  };
  const onFitViewHandler = () => {
    fitView(fitViewOptions);
    onFitView == null ? void 0 : onFitView();
  };
  const onToggleInteractivity = () => {
    store.setState({
      nodesDraggable: !isInteractive,
      nodesConnectable: !isInteractive,
      elementsSelectable: !isInteractive
    });
    onInteractiveChange == null ? void 0 : onInteractiveChange(!isInteractive);
  };
  return import_react2.default.createElement(
    Panel,
    { className: cc(["react-flow__controls", className]), position, style, "data-testid": "rf__controls" },
    showZoom && import_react2.default.createElement(
      import_react2.default.Fragment,
      null,
      import_react2.default.createElement(
        ControlButton,
        { onClick: onZoomInHandler, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: maxZoomReached },
        import_react2.default.createElement(PlusIcon, null)
      ),
      import_react2.default.createElement(
        ControlButton,
        { onClick: onZoomOutHandler, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: minZoomReached },
        import_react2.default.createElement(MinusIcon, null)
      )
    ),
    showFitView && import_react2.default.createElement(
      ControlButton,
      { className: "react-flow__controls-fitview", onClick: onFitViewHandler, title: "fit view", "aria-label": "fit view" },
      import_react2.default.createElement(FitViewIcon, null)
    ),
    showInteractive && import_react2.default.createElement(ControlButton, { className: "react-flow__controls-interactive", onClick: onToggleInteractivity, title: "toggle interactivity", "aria-label": "toggle interactivity" }, isInteractive ? import_react2.default.createElement(UnlockIcon, null) : import_react2.default.createElement(LockIcon, null)),
    children
  );
};
Controls.displayName = "Controls";
var Controls$1 = (0, import_react2.memo)(Controls);

// node_modules/@reactflow/background/dist/esm/index.mjs
var import_react3 = __toESM(require_react(), 1);
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
  BackgroundVariant2["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));
function LinePattern({ color, dimensions, lineWidth }) {
  return import_react3.default.createElement("path", { stroke: color, strokeWidth: lineWidth, d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}` });
}
function DotPattern({ color, radius }) {
  return import_react3.default.createElement("circle", { cx: radius, cy: radius, r: radius, fill: color });
}
var defaultColor = {
  [BackgroundVariant.Dots]: "#91919a",
  [BackgroundVariant.Lines]: "#eee",
  [BackgroundVariant.Cross]: "#e2e2e2"
};
var defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
};
var selector3 = (s) => ({ transform: s.transform, patternId: `pattern-${s.rfId}` });
function Background({
  id,
  variant = BackgroundVariant.Dots,
  // only used for dots and cross
  gap = 20,
  // only used for lines and cross
  size,
  lineWidth = 1,
  offset = 2,
  color,
  style,
  className
}) {
  const ref = (0, import_react3.useRef)(null);
  const { transform, patternId } = useStore(selector3, shallow$1);
  const patternColor = color || defaultColor[variant];
  const patternSize = size || defaultSize[variant];
  const isDots = variant === BackgroundVariant.Dots;
  const isCross = variant === BackgroundVariant.Cross;
  const gapXY = Array.isArray(gap) ? gap : [gap, gap];
  const scaledGap = [gapXY[0] * transform[2] || 1, gapXY[1] * transform[2] || 1];
  const scaledSize = patternSize * transform[2];
  const patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap;
  const patternOffset = isDots ? [scaledSize / offset, scaledSize / offset] : [patternDimensions[0] / offset, patternDimensions[1] / offset];
  return import_react3.default.createElement(
    "svg",
    { className: cc(["react-flow__background", className]), style: {
      ...style,
      position: "absolute",
      width: "100%",
      height: "100%",
      top: 0,
      left: 0
    }, ref, "data-testid": "rf__background" },
    import_react3.default.createElement("pattern", { id: patternId + id, x: transform[0] % scaledGap[0], y: transform[1] % scaledGap[1], width: scaledGap[0], height: scaledGap[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${patternOffset[0]},-${patternOffset[1]})` }, isDots ? import_react3.default.createElement(DotPattern, { color: patternColor, radius: scaledSize / offset }) : import_react3.default.createElement(LinePattern, { dimensions: patternDimensions, color: patternColor, lineWidth })),
    import_react3.default.createElement("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${patternId + id})` })
  );
}
Background.displayName = "Background";
var Background$1 = (0, import_react3.memo)(Background);

// node_modules/@reactflow/node-toolbar/dist/esm/index.mjs
var import_react4 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var selector4 = (state) => {
  var _a;
  return (_a = state.domNode) == null ? void 0 : _a.querySelector(".react-flow__renderer");
};
function NodeToolbarPortal({ children }) {
  const wrapperRef = useStore(selector4);
  if (!wrapperRef) {
    return null;
  }
  return (0, import_react_dom.createPortal)(children, wrapperRef);
}
var nodeEqualityFn = (a, b) => {
  var _a, _b, _c, _d, _e, _f;
  return ((_a = a == null ? void 0 : a.positionAbsolute) == null ? void 0 : _a.x) === ((_b = b == null ? void 0 : b.positionAbsolute) == null ? void 0 : _b.x) && ((_c = a == null ? void 0 : a.positionAbsolute) == null ? void 0 : _c.y) === ((_d = b == null ? void 0 : b.positionAbsolute) == null ? void 0 : _d.y) && (a == null ? void 0 : a.width) === (b == null ? void 0 : b.width) && (a == null ? void 0 : a.height) === (b == null ? void 0 : b.height) && (a == null ? void 0 : a.selected) === (b == null ? void 0 : b.selected) && ((_e = a == null ? void 0 : a[internalsSymbol]) == null ? void 0 : _e.z) === ((_f = b == null ? void 0 : b[internalsSymbol]) == null ? void 0 : _f.z);
};
var nodesEqualityFn = (a, b) => {
  return a.length === b.length && a.every((node, i) => nodeEqualityFn(node, b[i]));
};
var storeSelector = (state) => ({
  transform: state.transform,
  nodeOrigin: state.nodeOrigin,
  selectedNodesCount: state.getNodes().filter((node) => node.selected).length
});
function getTransform(nodeRect, transform, position, offset, align) {
  let alignmentOffset = 0.5;
  if (align === "start") {
    alignmentOffset = 0;
  } else if (align === "end") {
    alignmentOffset = 1;
  }
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * transform[2] + transform[0],
    nodeRect.y * transform[2] + transform[1] - offset
  ];
  let shift = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * transform[2] + transform[0] + offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * transform[2] + transform[1]
      ];
      shift = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * transform[2] + transform[1] + offset;
      shift[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * transform[2] + transform[0] - offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * transform[2] + transform[1]
      ];
      shift = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;
}
function NodeToolbar({ nodeId, children, className, style, isVisible, position = Position.Top, offset = 10, align = "center", ...rest }) {
  const contextNodeId = useNodeId();
  const nodesSelector = (0, import_react4.useCallback)((state) => {
    const nodeIds = Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId || ""];
    return nodeIds.reduce((acc, id) => {
      const node = state.nodeInternals.get(id);
      if (node) {
        acc.push(node);
      }
      return acc;
    }, []);
  }, [nodeId, contextNodeId]);
  const nodes = useStore(nodesSelector, nodesEqualityFn);
  const { transform, nodeOrigin, selectedNodesCount } = useStore(storeSelector, shallow$1);
  const isActive = typeof isVisible === "boolean" ? isVisible : nodes.length === 1 && nodes[0].selected && selectedNodesCount === 1;
  if (!isActive || !nodes.length) {
    return null;
  }
  const nodeRect = getNodesBounds(nodes, nodeOrigin);
  const zIndex = Math.max(...nodes.map((node) => {
    var _a;
    return (((_a = node[internalsSymbol]) == null ? void 0 : _a.z) || 1) + 1;
  }));
  const wrapperStyle = {
    position: "absolute",
    transform: getTransform(nodeRect, transform, position, offset, align),
    zIndex,
    ...style
  };
  return import_react4.default.createElement(
    NodeToolbarPortal,
    null,
    import_react4.default.createElement("div", { style: wrapperStyle, className: cc(["react-flow__node-toolbar", className]), ...rest }, children)
  );
}

// node_modules/@reactflow/node-resizer/dist/esm/index.mjs
var import_react5 = __toESM(require_react(), 1);
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2["Line"] = "line";
  ResizeControlVariant2["Handle"] = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
function getDirection({ width, prevWidth, height, prevHeight, invertX, invertY }) {
  const deltaWidth = width - prevWidth;
  const deltaHeight = height - prevHeight;
  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  if (deltaWidth && invertX) {
    direction[0] = direction[0] * -1;
  }
  if (deltaHeight && invertY) {
    direction[1] = direction[1] * -1;
  }
  return direction;
}
var initPrevValues = { width: 0, height: 0, x: 0, y: 0 };
var initStartValues = {
  ...initPrevValues,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function ResizeControl({ nodeId, position, variant = ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {
  const contextNodeId = useNodeId();
  const id = typeof nodeId === "string" ? nodeId : contextNodeId;
  const store = useStoreApi();
  const resizeControlRef = (0, import_react5.useRef)(null);
  const startValues = (0, import_react5.useRef)(initStartValues);
  const prevValues = (0, import_react5.useRef)(initPrevValues);
  const getPointerPosition = useGetPointerPosition();
  const defaultPosition = variant === ResizeControlVariant.Line ? "right" : "bottom-right";
  const controlPosition = position ?? defaultPosition;
  (0, import_react5.useEffect)(() => {
    if (!resizeControlRef.current || !id) {
      return;
    }
    const selection = select_default(resizeControlRef.current);
    const enableX = controlPosition.includes("right") || controlPosition.includes("left");
    const enableY = controlPosition.includes("bottom") || controlPosition.includes("top");
    const invertX = controlPosition.includes("left");
    const invertY = controlPosition.includes("top");
    const dragHandler = drag_default().on("start", (event) => {
      const node = store.getState().nodeInternals.get(id);
      const { xSnapped, ySnapped } = getPointerPosition(event);
      prevValues.current = {
        width: (node == null ? void 0 : node.width) ?? 0,
        height: (node == null ? void 0 : node.height) ?? 0,
        x: (node == null ? void 0 : node.position.x) ?? 0,
        y: (node == null ? void 0 : node.position.y) ?? 0
      };
      startValues.current = {
        ...prevValues.current,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.current.width / prevValues.current.height
      };
      onResizeStart == null ? void 0 : onResizeStart(event, { ...prevValues.current });
    }).on("drag", (event) => {
      const { nodeInternals, triggerNodeChanges } = store.getState();
      const { xSnapped, ySnapped } = getPointerPosition(event);
      const node = nodeInternals.get(id);
      if (node) {
        const changes = [];
        const { pointerX: startX, pointerY: startY, width: startWidth, height: startHeight, x: startNodeX, y: startNodeY, aspectRatio } = startValues.current;
        const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues.current;
        const distX = Math.floor(enableX ? xSnapped - startX : 0);
        const distY = Math.floor(enableY ? ySnapped - startY : 0);
        let width = clamp(startWidth + (invertX ? -distX : distX), minWidth, maxWidth);
        let height = clamp(startHeight + (invertY ? -distY : distY), minHeight, maxHeight);
        if (keepAspectRatio) {
          const nextAspectRatio = width / height;
          const isDiagonal = enableX && enableY;
          const isHorizontal = enableX && !enableY;
          const isVertical = enableY && !enableX;
          width = nextAspectRatio <= aspectRatio && isDiagonal || isVertical ? height * aspectRatio : width;
          height = nextAspectRatio > aspectRatio && isDiagonal || isHorizontal ? width / aspectRatio : height;
          if (width >= maxWidth) {
            width = maxWidth;
            height = maxWidth / aspectRatio;
          } else if (width <= minWidth) {
            width = minWidth;
            height = minWidth / aspectRatio;
          }
          if (height >= maxHeight) {
            height = maxHeight;
            width = maxHeight * aspectRatio;
          } else if (height <= minHeight) {
            height = minHeight;
            width = minHeight * aspectRatio;
          }
        }
        const isWidthChange = width !== prevWidth;
        const isHeightChange = height !== prevHeight;
        if (invertX || invertY) {
          const x = invertX ? startNodeX - (width - startWidth) : startNodeX;
          const y = invertY ? startNodeY - (height - startHeight) : startNodeY;
          const isXPosChange = x !== prevX && isWidthChange;
          const isYPosChange = y !== prevY && isHeightChange;
          if (isXPosChange || isYPosChange) {
            const positionChange = {
              id: node.id,
              type: "position",
              position: {
                x: isXPosChange ? x : prevX,
                y: isYPosChange ? y : prevY
              }
            };
            changes.push(positionChange);
            prevValues.current.x = positionChange.position.x;
            prevValues.current.y = positionChange.position.y;
          }
        }
        if (isWidthChange || isHeightChange) {
          const dimensionChange = {
            id,
            type: "dimensions",
            updateStyle: true,
            resizing: true,
            dimensions: {
              width,
              height
            }
          };
          changes.push(dimensionChange);
          prevValues.current.width = width;
          prevValues.current.height = height;
        }
        if (changes.length === 0) {
          return;
        }
        const direction = getDirection({
          width: prevValues.current.width,
          prevWidth,
          height: prevValues.current.height,
          prevHeight,
          invertX,
          invertY
        });
        const nextValues = { ...prevValues.current, direction };
        const callResize = shouldResize == null ? void 0 : shouldResize(event, nextValues);
        if (callResize === false) {
          return;
        }
        onResize == null ? void 0 : onResize(event, nextValues);
        triggerNodeChanges(changes);
      }
    }).on("end", (event) => {
      const dimensionChange = {
        id,
        type: "dimensions",
        resizing: false
      };
      onResizeEnd == null ? void 0 : onResizeEnd(event, { ...prevValues.current });
      store.getState().triggerNodeChanges([dimensionChange]);
    });
    selection.call(dragHandler);
    return () => {
      selection.on(".drag", null);
    };
  }, [
    id,
    controlPosition,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    getPointerPosition,
    onResizeStart,
    onResize,
    onResizeEnd
  ]);
  const positionClassNames = controlPosition.split("-");
  const colorStyleProp = variant === ResizeControlVariant.Line ? "borderColor" : "backgroundColor";
  const controlStyle = color ? { ...style, [colorStyleProp]: color } : style;
  return import_react5.default.createElement("div", { className: cc(["react-flow__resize-control", "nodrag", ...positionClassNames, variant, className]), ref: resizeControlRef, style: controlStyle }, children);
}
var ResizeControl$1 = (0, import_react5.memo)(ResizeControl);
var handleControls = ["top-left", "top-right", "bottom-left", "bottom-right"];
var lineControls = ["top", "right", "bottom", "left"];
function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {
  if (!isVisible) {
    return null;
  }
  return import_react5.default.createElement(
    import_react5.default.Fragment,
    null,
    lineControls.map((c) => import_react5.default.createElement(ResizeControl$1, { key: c, className: lineClassName, style: lineStyle, nodeId, position: c, variant: ResizeControlVariant.Line, color, minWidth, minHeight, maxWidth, maxHeight, onResizeStart, keepAspectRatio, shouldResize, onResize, onResizeEnd })),
    handleControls.map((c) => import_react5.default.createElement(ResizeControl$1, { key: c, className: handleClassName, style: handleStyle, nodeId, position: c, color, minWidth, minHeight, maxWidth, maxHeight, onResizeStart, keepAspectRatio, shouldResize, onResize, onResizeEnd }))
  );
}
export {
  Background$1 as Background,
  BackgroundVariant,
  BaseEdge,
  BezierEdge,
  ConnectionLineType,
  ConnectionMode,
  ControlButton,
  Controls$1 as Controls,
  EdgeLabelRenderer,
  EdgeText$1 as EdgeText,
  Handle$1 as Handle,
  MarkerType,
  MiniMap$1 as MiniMap,
  ResizeControl$1 as NodeResizeControl,
  NodeResizer,
  NodeToolbar,
  PanOnScrollMode,
  Panel,
  Position,
  ReactFlow,
  ReactFlowProvider,
  ResizeControlVariant,
  SelectionMode,
  SimpleBezierEdge,
  SmoothStepEdge,
  StepEdge,
  StraightEdge,
  addEdge,
  applyEdgeChanges,
  applyNodeChanges,
  boxToRect,
  clamp,
  ReactFlow as default,
  getBezierPath,
  getBoundsOfRects,
  getConnectedEdges,
  getIncomers,
  getMarkerEnd,
  getNodePositionWithOrigin,
  getNodesBounds,
  getOutgoers,
  getRectOfNodes,
  getSimpleBezierPath,
  getSmoothStepPath,
  getStraightPath,
  getTransformForBounds,
  getViewportForBounds,
  handleParentExpand,
  internalsSymbol,
  isEdge,
  isNode,
  reconnectEdge,
  rectToBox,
  updateEdge,
  useEdges,
  useEdgesState,
  useGetPointerPosition,
  useKeyPress,
  useNodeId,
  useNodes,
  useNodesInitialized,
  useNodesState,
  useOnSelectionChange,
  useOnViewportChange,
  useReactFlow,
  useStore,
  useStoreApi,
  useUpdateNodeInternals,
  useViewport
};
//# sourceMappingURL=reactflow.js.map
