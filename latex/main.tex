\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage{lmodern}
\usepackage[polish]{babel}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{longtable}
\usepackage{tabularx}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{colortbl}
\usepackage{xcolor}
\usepackage{array}
\usepackage{tocloft}
\usepackage{float}
\usepackage{caption}
\usepackage{tikz}
\usetikzlibrary{matrix,calc,positioning,shapes.geometric}
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}
\usepackage[hidelinks]{hyperref}
\usepackage{csquotes}
\usepackage{enumitem}
\usepackage{setspace}
\usepackage{indentfirst}
\setlength{\parindent}{1.5em}
\usepackage{sectsty}
\sectionfont{\fontsize{16pt}{18pt}\selectfont}
\subsectionfont{\fontsize{14pt}{16pt}\selectfont}
\AtBeginDocument{\onehalfspacing}
\renewcommand{\figurename}{Rys.}

\lstdefinestyle{myStyle}{
    backgroundcolor=\color{white},
    basicstyle=\ttfamily,
    breaklines=true,
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    captionpos=b
}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{2cm}
    \includegraphics[width=0.5\textwidth]{Uniwersytet_Bielsko-Bialski_-_logo.jpg}\par\vspace{1cm}
    \textsc{\LARGE Uniwersytet Bielsko-Bialski}\par\vspace{1.5cm}
    \textsc{\Large Praca inżynierska}\par\vspace{0.5cm}
    {\huge\bfseries System low-code do budowy interfejsów API}\par
    \vspace{2cm}
    \begin{flushleft}
        \large
        \textbf{Autor:}\\
        Konrad Firlej\\
        Numer Karty Studenckiej: 60043\\
    \end{flushleft}
    \vspace{1cm}
    \begin{flushleft}
        \large
        \textbf{Promotor:}\\
        dr inż. Krzysztof Augustynek\\
    \end{flushleft}
    \vfill
    {\large 13 czerwca 2025}
\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Wprowadzenie}

\subsection{Wstęp}
Tematem pracy jest projekt i implementacja Flowforge, aplikacji low-code ułatwiającej tworzenie i udostępnianie przepływów danych jako API. W praktyce zespoły programistyczne często marnują czas na ręczne sklejanie powtarzalnych integracji, walczą z niespójną dokumentacją oraz brakiem podglądu wykonania. Flowforge łączy wizualny edytor bloków z backendem HTTP, dzięki czemu użytkownik układa logikę na canvasie, a serwer udostępnia gotowy endpoint do uruchamiania przepływu.

\subsection{Cel pracy}
Celem pracy jest zbudowanie lekkiej platformy, która pozwala wizualnie konstruować przepływy i udostępniać je jako wywoływalne API, równocześnie zapewniając planowanie uruchomień, ręczne wywołania, wgląd w historię i wyniki oraz spójny interfejs w jasnym i ciemnym motywie, tak aby zminimalizować konieczność pisania kodu backendowego przy zachowaniu przejrzystości i możliwości audytu.

\subsection{Przegląd rozdziałów}
Rozdział pierwszy wprowadza czytelnika: przedstawia motywację, cel pracy i tło rynkowe, pokazując, jakie problemy integracyjne Flowforge ma rozwiązać oraz jak pozycjonuje się względem istniejących platform low-code/no-code. Rozdział drugi prowadzi przez projekt rozwiązania: zaczyna od modelu dziedziny i wymagań, następnie opisuje kluczowe przypadki użycia, architekturę logiczną i fizyczną, model danych oraz szkice interfejsu obejmujące edytor blokowy, listy workflowów, harmonogram i widok wykonań. Trzeci rozdział omawia implementację, strukturę kodu, wybrane decyzje techniczne i konfigurację środowisk. Rozdział czwarty podsumowuje rezultaty, wskazuje ograniczenia obecnej wersji i proponuje kierunki dalszego rozwoju (np. edytor bloków niestandardowych, rozbudowa telemetrii, nowe konektory).

\newpage
\subsection{Przegląd istniejących rozwiązań}
Aby osadzić Flowforge w kontekście rynku, warto zestawić je z najczęściej używanymi platformami automatyzacji. Poniższe punkty będą uzupełnione zrzutami ekranu (widok budowy przepływu lub listy automatyzacji) dla zobrazowania ergonomii interfejsu:
\begin{itemize}[noitemsep, topsep=0pt, leftmargin=*]
    \item \textbf{n8n}\footnote{https://n8n.io} to edytor blokowy z dużym katalogiem konektorów oraz opcją hostowania lokalnego. Przy bardziej złożonych scenariuszach użytkownik często dopisuje własne skrypty JavaScript, a wersjonowanie i testy regresyjne trzeba budować samodzielnie.\\[2pt]
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.55\linewidth]{img/n8n.png}
    \caption{Przykładowy widok edytora przepływu w n8n}
    \end{figure}
\end{itemize}

\begin{itemize}[noitemsep, topsep=0pt, leftmargin=*]
    \item \textbf{Node-RED}\footnote{https://nodered.org} to lekkie narzędzie często używane w IoT, łatwe w instalacji i rozbudowie o własne node'y. Brakuje w nim jednak wygodnej historii wykonań zapytań HTTP oraz kontroli wersji przepływów, co utrudnia audyt i współpracę zespołową.\\[2pt]
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.55\linewidth]{img/Node-RED.png}
    \caption{Przykładowy widok przepływu w Node-RED}
    \end{figure}
    \newpage
    \item \textbf{Zapier}\footnote{https://zapier.com} oferuje bardzo szeroki ekosystem integracji SaaS i szybki start w chmurze, ale dane pozostają poza kontrolą użytkownika, logi są ograniczone czasowo, a brak wariantu do samodzielnego hostowania podnosi koszty dla firm z restrykcyjnymi wymaganiami.\\[2pt]
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.55\linewidth]{img/zapier.png}
    \caption{Widok listy automatyzacji w Zapier}
    \end{figure}
    \item \textbf{Power Automate}\footnote{https://powerautomate.microsoft.com} jest mocno zintegrowane z pakietem Microsoft 365 i usługami Azure. Wymaga subskrypcji, a eksport i przenoszenie przepływów poza tenant bywa ograniczone, co utrudnia migracje i testy w izolowanych środowiskach.\\[2pt]
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.55\linewidth]{img/powerautomate.png}
    \caption{Widok przepływu w Power Automate}
    \end{figure}
\end{itemize}

Flowforge ma powstać jako lżejsza alternatywa. System instaluje się lokalnie lub w prywatnej chmurze, a opublikowana wersja workflow automatycznie wystawia endpoint HTTP do wywołania (np. \texttt{/api/run/\{workflowId\}}) z walidacją wejścia. Wbudowana obserwowalność obejmuje historię wykonań, scheduler oraz podgląd ścieżki bloków. Całość działa w jasnym i ciemnym motywie i nie wymaga subskrypcji zewnętrznej chmury.

\newpage
\section{Projekt aplikacji}
Ten rozdział opisuje koncepcję budowanego systemu z uwzględnieniem dobrych praktyk inżynierii oprogramowania. Układ podsekcji odzwierciedla naturalny porządek pracy: od zrozumienia domeny, przez wymagania i przypadki użycia, po architekturę, model danych oraz interfejs.

\subsection{Analiza dziedziny problemowej}
Punktem wyjścia jest zrozumienie, jakie problemy chcemy rozwiązać w obszarze automatyzacji przepływów danych. Obecnie integracje API powstają często jako ad-hoc „spoiwo” pisane w skryptach, co utrudnia ponowne użycie, audyt i utrzymanie. Zespoły potrzebują narzędzia, które pozwoli im szybko składać sekwencje wywołań HTTP, walidować i transformować dane, planować uruchomienia oraz śledzić historię wykonań bez zagłębiania się w infrastrukturę.

W kontekście Flowforge istotnymi bytami domenowymi są:
\begin{itemize}[noitemsep, topsep=0pt, leftmargin=*]
    \item \textbf{Workflow}. Główny artefakt użytkownika traktowany jako projekt. Budowany w edytorze blokowym opisuje cały przepływ danych i jest udostępniany jako wywoływalne API. Wspiera wersjonowanie i statusy publikacji.
    \item \textbf{Block}. Atomowa czynność w przepływie. Blok posiada konfigurację oraz porty połączeń (wejścia i wyjścia), które pozwalają definiować kolejność i gałęzie wykonania.
    \item \textbf{Connection}. Połączenie między blokami, które wyznacza kolejność przejścia oraz przebieg gałęzi warunkowych w przepływie.
    \item \textbf{Variable}. Nazwana wartość wejściowa lub wyjściowa workflow. Służy do przenoszenia danych między blokami oraz do parametrów wywołania API.
    \item \textbf{Execution}. Pojedyncze uruchomienie workflow, przechowuje ścieżkę wykonaną przez bloki, payload wejściowy i wyjściowy oraz logi.
    \item \textbf{Version/Snapshot}. Zapis stanu workflow w danym momencie, który umożliwia powrót do stabilnej konfiguracji. Wersje mogą być eksportowane i importowane między instancjami systemu.
    \item \textbf{Schedule}. Definicja planowanego uruchamiania workflow (jednorazowego lub cyklicznego) z parametrami daty i godziny, strefy czasowej pobranej z przeglądarki lub wybranej ręcznie oraz flagą włączenia.
    \item \textbf{Block Library}. Katalog systemowych typów bloków dostępny bezpośrednio w aplikacji, z podglądem wyglądu i tym samym panelem konfiguracyjnym co w edytorze. Każdy wpis przechowuje schemat pól, podstawową walidację oraz pokazuje docelowy kształt bloczka (styl, porty, ikona ustawień).
\end{itemize}

Reguły wynikające z pracy użytkownika w edytorze są spójne z powyższymi bytami. Nazwy workflow, wersji, snapshotów i harmonogramów muszą być unikalne w obrębie projektu, by dało się je łatwo znaleźć w listach i w historii wykonań. Edycja zawsze odbywa się na wersji roboczej, a publikacja zamraża konfigurację do uruchomień. Execution odwołuje się wyłącznie do opublikowanej wersji i zapisuje ścieżkę bloków oraz logi. Każde połączenie łączy konkretne porty: Start nie ma wejścia, End nie ma wyjścia, a bloki warunkowe czy Switch posiadają wiele wyjść. Pola konfiguracyjne bloków są walidowane (adresy URL, liczby, flagi) przed zapisaniem, a zmienne muszą mieć niepuste nazwy wspólne dla całego workflow, by można je było wstrzykiwać i odczytywać w kolejnych blokach. Snapshot jest niezmienny. Każda zmiana tworzy nową wersję. Harmonogram wymaga daty, godziny i strefy czasowej (domyślnie pobranej z przeglądarki, z możliwością ręcznego wyboru) i nie pozwala ustawić startu w przeszłości względem wybranej strefy. Import/eksport wersji przenosi spójne identyfikatory bloków i zmiennych, aby po wgraniu odtworzyć ten sam przepływ. Biblioteka bloków stanowi źródło prawdy: tylko bloki z katalogu mogą zostać użyte, a każdy ma zdefiniowane porty i schemat pól konfiguracyjnych, które są prezentowane także na karcie „Blocks”.

Tak zdefiniowana dziedzina wyznacza zakres funkcjonalny projektu: wizualny edytor blokowy, zarządzanie wersjami, uruchomienia ręczne i zaplanowane, podgląd historii i wyników, a także kontrolę nad danymi bez uzależnienia od chmury zewnętrznej.

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/DomainModel.png}
\caption{Diagram domenowy systemu Flowforge}
\end{figure}

\newpage
\subsection{Specyfikacja wymagań}
\vspace{6pt}
Na etapie analizy wymagań oraz ich specyfikacji należy precyzyjnie opisać, czego będzie oczekiwał użytkownik i jakie ramy techniczne ma spełnić system. Poniższe punkty odzwierciedlają planowane możliwości edytora blokowego oraz widoków Workflows, Executions, Scheduler i Blocks, a także zasady wersjonowania i planowania uruchomień, które mają zostać zaimplementowane.
\subsubsection*{Wymagania funkcjonalne}
\begin{itemize}[nosep]
    \item Użytkownik może zbudować workflow w edytorze blokowym, dodając z palety bloki Start, End, If, Switch, Calculation, Text Transform, Text Replace, HTTP Request, Parser i Wait oraz łącząc ich porty wejść i wyjść.
    \item Użytkownik może zapisać wersję roboczą, opublikować wersję wykonywalną i utworzyć snapshot do późniejszego przywrócenia lub eksportu; nazwa workflow nie musi być unikalna, rozróżnienie następuje po identyfikatorach wersji i snapshotów.
    \item Użytkownik może konfigurować każdy blok, a interfejs oraz API sprawdzają poprawność pól. W polach można wprowadzać zmienne globalne zapisane w workflow przez \texttt{\$nazwa}; błędna lub brakująca zmienna jest sygnalizowana.
    \item Użytkownik może na liście Workflows otworzyć edytor, przejrzeć snapshoty, uruchomić workflow ręcznie z danymi wejściowymi i zobaczyć opublikowane wersje.
    \item Użytkownik może w widoku Executions sprawdzić historię uruchomień, przefiltrować listę, otworzyć szczegóły pojedynczego przebiegu, obejrzeć metadane, dane wejściowe i wyjściowe, ścieżkę bloków oraz logi.
    \item Użytkownik może z run drawera uruchomić workflow na żądanie, wprowadzić wartości zmiennych, a po zakończeniu obejrzeć wyniki bez opuszczania panelu.
    \item Użytkownik może utworzyć harmonogram, edytować go, włączyć lub wyłączyć oraz uruchomić natychmiast. Strefa czasowa jest pobierana z przeglądarki lub wybierana ręcznie, a termin startu nie może leżeć w przeszłości względem tej strefy.
    \item Użytkownik może importować i eksportować snapshoty, zachowując identyfikatory bloków, połączeń i zmiennych tak, aby po wgraniu odtworzyć ten sam przepływ.
    \item Użytkownik może w widoku Blocks zobaczyć wszystkie typy bloków, ich wygląd i panel konfiguracji identyczny jak w edytorze, bez zapisywania zmian.
    \item Użytkownik może przełączyć jasny i ciemny motyw oraz pracować na tych samych widokach Workflows, Executions, Scheduler, Blocks i edytorze.
\end{itemize}
\newpage
\subsubsection*{Wymagania niefunkcjonalne}
\begin{itemize}[nosep]
    \item UI działa w przeglądarkach Chromium i Firefox w rozdzielczości co najmniej Full HD i zachowuje responsywny układ list oraz edytora.
    \item Walidacja pól odbywa się po stronie klienta i serwera; komunikaty są powiązane z konkretnym polem i nie blokują innych działań na stronie.
    \item Edytor z pustym workflow uruchamia się w kilka sekund w środowisku deweloperskim, a dodawanie i przesuwanie bloków jest płynne.
    \item Harmonogram zapisuje czas w UTC, prezentuje go w strefie użytkownika i obsługuje wszystkie strefy dostępne w przeglądarce.
    \item Dane o wersjach, snapshotach, harmonogramach i uruchomieniach są trwałe w bazie; eksport snapshotów nie wymaga usług zewnętrznych.
    \item Motywy jasny i ciemny zachowują spójną typografię i kolorystykę między widokami.
    \item Środowisko buildów jest odtwarzalne: frontend uruchamiany poleceniami npm w katalogu `flowforge.ui`, backend przez `dotnet` na rozwiązaniu.
    \item Testy jednostkowe backendu (NUnit) można uruchamiać niezależnie od pozostałych komponentów.
\end{itemize}
Warstwa niefunkcjonalna opisuje tempo i jakość pracy interfejsu, pełną walidację po kliencie i serwerze, prawidłową obsługę stref czasowych, trwałość danych oraz powtarzalne procesy buildów i testów.
\subsection{Model przypadków użycia}
\vspace{6pt}
\begin{figure}[H]
\centering
\includegraphics[width=0.70\linewidth]{img/UseCases.png}
\caption{Przypadki użycia Flowforge. Zgrupowane według widoków UI i powiązań z backendem}
\label{fig:usecases}
\end{figure}
\noindent
\newpage
Diagram prowadzi użytkownika przez kolejne grupy akcji:
\begin{itemize}[noitemsep, topsep=4pt, leftmargin=*]
    \item \textbf{Workflows}: utworzenie nowego projektu, zmiana nazwy, podgląd wersji i snapshotów, import/eksport snapshotu JSON, publikacja wersji oraz wejście do edytora.
    \item \textbf{Editor}: dodawanie i układanie bloków, konfiguracja parametrów i zmiennych, walidacja pól (URL, liczby, nazwy zmiennych) oraz uruchomienie z run drawera bez opuszczania edytora.
    \item \textbf{Executions}: przegląd historii, filtrowanie/stronicowanie, szczegóły pojedynczego przebiegu wraz z danymi wejścia/wyjścia, statusem, logami i ścieżką bloków.
    \item \textbf{Scheduler}: tworzenie i edycja harmonogramu, wybór strefy czasowej (prezentacja w strefie użytkownika, zapis w UTC), aktywacja/dezaktywacja oraz „Wyzwól teraz”, które trafia do endpointu harmonogramu i uruchamia workflow.
    \item \textbf{Blocks}: podgląd biblioteki bloków i ich konfiguracji bez zapisywania, aby poznać parametry przed dodaniem do edytora.
    \item \textbf{API/Backend}: każda akcja UI wywołuje serwer (zapis workflow, walidacja snapshotu, uruchomienie workflow, historia wykonań, zarządzanie harmonogramem, walidacja importu/eksportu), a aktor „system zewnętrzny” symbolizuje klienta API korzystającego z uruchomień oraz importu/eksportu poza UI.
\end{itemize}
Kolory strzałek rozróżniają ścieżki użytkownika, a relacje include oznaczają czynności wspólne. Jeden diagram pokazuje pełny przepływ od listy workflow przez edytor, wykonania i scheduler aż po warstwę backendu.

\newpage
\subsection{Specyfikacja przypadków użycia}
\vspace{6pt}
\noindent
Poniższe diagramy uszczegóławiają pojedyncze akcje użytkownika w interfejsie Flowforge. Każdy rysunek pokazuje kroki prowadzące do sukcesu oraz główną ścieżkę alternatywną (anulowanie lub błąd walidacji).

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-create-workflow.png}
  \caption{Utworzenie nowego workflow z listy Workflows. Użytkownik wypełnia formularz i zapisuje szkic przepływu}
  \label{fig:uc-create-workflow}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-import-snapshot.png}
  \caption{Import snapshotu z menu More. Wskazanie pliku JSON i dodanie wersji po pozytywnej walidacji}
  \label{fig:uc-import}
\end{minipage}

\vspace{2pt}

\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-export-snapshot.png}
  \caption{Eksport snapshotu do pliku JSON. Zapis bieżącej konfiguracji przepływu do pobrania}
  \label{fig:uc-export}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-rename-workflow.png}
  \caption{Zmiana nazwy workflow w menu More. Wprowadzenie nowej etykiety i zapis na liście}
  \label{fig:uc-rename}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-publish-workflow.png}
  \caption{Publikacja wersji workflow. Wersja robocza staje się wykonywalna, endpoint HTTP dostępny}
  \label{fig:uc-publish}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-execution-details.png}
  \caption{Przegląd szczegółów uruchomienia. Wejście, wyjście, logi, ścieżka bloków oraz opcja ponownego uruchomienia}
  \label{fig:uc-execution-details-2}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-run-drawer.png}
  \caption{Ręczne uruchomienie workflow z run drawera. Wprowadzenie zmiennych i start bez wychodzenia z edytora}
  \label{fig:uc-run-drawer}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-add-block.png}
  \caption{Dodanie nowego bloku na canvas. Przeciągnięcie z palety i umieszczenie między portami}
  \label{fig:uc-add-block}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-configure-block.png}
  \caption{Konfiguracja parametrów bloku. Uzupełnienie pól, walidacja i zapis ustawień}
  \label{fig:uc-configure-block}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-block-preview.png}
  \caption{Podgląd bloku w sekcji Blocks. Mini-canvas i panel konfiguracji bez zapisywania zmian}
  \label{fig:uc-block-preview}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-save-draft.png}
  \caption{Zapis wersji roboczej w edytorze. Aktualizacja szkicu workflow w bazie}
  \label{fig:uc-save-draft}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-validate-blocks.png}
  \caption{Walidacja konfiguracji bloków przy zapisie/publikacji. Błędne pola blokują zapis do wersji}
  \label{fig:uc-validate-blocks}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-schedule.png}
  \caption{Utworzenie lub edycja harmonogramu. Ustawienie daty, godziny i strefy czasowej przed zapisaniem}
  \label{fig:uc-schedule}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-toggle-scheduler.png}
  \caption{Aktywacja lub dezaktywacja harmonogramu. Przełącznik statusu z natychmiastowym zapisem}
  \label{fig:uc-toggle-scheduler}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-run-now.png}
  \caption{Wyzwolenie istniejącego harmonogramu opcją „Wyzwól teraz”. Jednorazowe uruchomienie zdefiniowanego przepływu}
  \label{fig:uc-run-now}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.28\textheight,keepaspectratio]{img/uc-set-timezone.png}
  \caption{Wybór strefy czasowej w formularzu harmonogramu. Automatyczna strefa z przeglądarki lub ręczny wybór}
\label{fig:uc-set-timezone}
\end{minipage}
\end{figure}

\newpage
\subsection{Architektura logiczna i fizyczna}
\vspace{6pt}
\noindent
W tej części opisujemy docelowy podział warstw, który ma zostać wdrożony. Po stronie klienta przewidujemy jedną aplikację SPA\footnote{Single Page Application\cite{spa}.} w React 19 (budowaną Vite, routowaną React Router, z edytorem opartym o React Flow)\cite{react}, komunikującą się wyłącznie po HTTP/JSON z REST API\footnote{Interfejs REST w ASP.NET Core Web API\cite{aspnetcore}.}.

Warstwa serwerowa pozostanie w ASP.NET Core\cite{aspnetcore}. Cienkie kontrolery REST przekazują żądania do serwisów domenowych, serwisy korzystają z repozytoriów, a EF Core\cite{efcore} zapisuje dane w pliku SQLite\cite{sqlite}. W tym samym procesie działa hosted service scheduler, który cyklicznie wyzwala zaplanowane uruchomienia. Serwer HTTP to Kestrel\footnote{Wbudowany serwer ASP.NET Core\cite{kestrel}.}, a wstrzykiwanie zależności DI\footnote{Dependency Injection w ASP.NET Core\cite{di}.} oraz DbContext EF Core utrzymują spójność konfiguracji danych.

W wymiarze fizycznym przewidujemy trzy artefakty: przeglądarka renderująca SPA, proces API Kestrel z DI/DbContextem i schedulerem oraz plik bazy na dysku. Rysunek \ref{fig:architecture} pokazuje, że SPA może być serwowane wspólnie z API albo z osobnego hostingu statycznego; decyzja wdrożeniowa nie zmienia kontraktu REST.

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth,keepaspectratio]{img/architecture.png}
\caption{Architektura fizyczna Flowforge. Przepływ komunikacji między SPA, API, schedulerem i bazą SQLite}
\label{fig:architecture}
\end{figure}

\noindent
Rysunek \ref{fig:architecture} obrazuje planowany przepływ: SPA odpytuje API, kontrolery kierują ruch do serwisów, te do repozytoriów i EF Core, a zapis trafia do SQLite. Scheduler działa równolegle w tym samym procesie, wywołując serwisy w tle.

Model backendu utrzymujemy jako warstwową kompozycję „Controllers.Services.Repositories” z DI; frontend pozostaje przy klientowskim renderowaniu SPA. Taki podział ma ułatwić testy, wymianę warstw danych i ewentualne rozdzielenie hostingu SPA i API bez zmiany kontraktu.

Podsumowanie decyzji architektonicznej: utrzymujemy SPA w React z dostawą statyczną, backend w ASP.NET Core z REST API, Kestrel i EF Core na SQLite, a scheduler jako hosted service w tym samym procesie. Ten układ minimalizuje zależności, pozwala rozwijać UI i API niezależnie, a jednocześnie zachowuje prostą ścieżkę wdrożenia na jednej maszynie lub w rozdzielonych hostach bez modyfikacji protokołów.

\subsection{Model informacyjny}
\vspace{6pt}
\noindent
Celem tej części jest przedstawienie pełnego modelu klas w notacji crow’s foot na podstawie kodu z \texttt{flowforge.api/Models}. Diagramy pokazują kardynalności i główne pola: rdzeń domeny (Rys. \ref{fig:er-core}), konfiguracje bloków (Rys. \ref{fig:er-configs}), dane pojedynczego uruchomienia (Rys. \ref{fig:er-execution}), harmonogram (Rys. \ref{fig:er-schedule}) oraz pomocnicze enumy (Rys. \ref{fig:er-enums}).

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.42\textheight,keepaspectratio]{img/er-core.png}
  \caption{ERD rdzenia: Workflow z blokami, połączeniami, zmiennymi, rewizjami, uruchomieniami i harmonogramami}
  \label{fig:er-core}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.42\textheight,keepaspectratio]{img/er-configs.png}
  \caption{ERD konfiguracji: typy JSON bloków (HTTP, parser, kalkulacja, if/switch) i relacje pomocniczych tabel}
  \label{fig:er-configs}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.38\textheight,keepaspectratio]{img/er-execution.png}
  \caption{ERD wykonania: WorkflowExecution z referencją do Workflow oraz polami serializującymi wejście, wynik i ścieżki}
  \label{fig:er-execution}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.38\textheight,keepaspectratio]{img/er-schedule.png}
  \caption{ERD harmonogramu: WorkflowSchedule przypięty do Workflow i opcjonalnej WorkflowRevision, z polami czasu i strefy}
  \label{fig:er-schedule}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth,keepaspectratio]{img/er-enums.png}
\caption{Enumy wspierające konfiguracje: ConnectionType, CalculationOperation, ConditionDataType, HttpRequestAuthType, ParserFormat}
\label{fig:er-enums}
\end{figure}

\newpage
\subsection{Interfejs użytkownika}
\vspace{6pt}
\noindent
Makiety UI ilustrują docelowy wygląd aplikacji w motywie jasnym i prezentują główne ekrany SPA widoczne dla użytkownika w przeglądarce. Zestaw obejmuje listę workflowów (z akcjami More, wersjami i importem), katalog bloków (mini-canvas i dostęp do konfiguracji), historię uruchomień, szczegóły pojedynczego runu, harmonogram oraz pracę w edytorze blokowym. Osobny kadr pokazuje konfigurację Parsera, czyli typowe pole formularza w drawrze bocznym.

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.32\textheight,keepaspectratio]{img/ui-workflows.png}
  \caption{Widok listy workflowów. Lista projektów z akcjami More i szybkim tworzeniem}
  \label{fig:ui-workflows}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.32\textheight,keepaspectratio]{img/ui-blocks.png}
  \caption{Widok Blocks. Katalog bloków z mini canvasem podglądu i dostępem do konfiguracji}
  \label{fig:ui-blocks}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.32\textheight,keepaspectratio]{img/ui-executions.png}
  \caption{Widok Executions. Historia uruchomień z podstawowymi metadanymi}
  \label{fig:ui-executions}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.32\textheight,keepaspectratio]{img/ui-execution-details.png}
  \caption{Widok Execution Details. Pełne dane wejścia/wyjścia, ścieżka bloków i logi}
  \label{fig:ui-execution-details}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.32\textheight,keepaspectratio]{img/ui-scheduler.png}
  \caption{Widok Scheduler. Lista harmonogramów z akcjami edycji, wyzwalania i zmianą strefy czasowej}
  \label{fig:ui-scheduler}
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}
  \centering
  \includegraphics[width=\linewidth,height=0.32\textheight,keepaspectratio]{img/ui-editor.png}
  \caption{Widok edytora workflow. Canvas React Flow zaraz po utworzeniu nowego skryptu}
  \label{fig:ui-editor}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth,keepaspectratio]{img/ui-parser-config.png}
\caption{Konfiguracja bloku Parser w edytorze. Pola formatu, źródła i mapowań do zmiennych w bocznym drawerze}
\label{fig:ui-parser-config}
\end{figure}

\newpage

\subsection{Projekt bazy danych}
\vspace{6pt}
\noindent
Schemat bazy ma układ \textit{hub-and-spoke}: \texttt{Workflows} jest węzłem centralnym, a rewizje, bloki, uruchomienia, harmonogramy i zmienne są satelitami spiętymi kluczami obcymi. To układ transakcyjny (nie star schema) i stanowi bazę dla edytora oraz schedulera. W środowisku deweloperskim zastosowano relacyjną bazę SQLite z mapowaniem przez Entity Framework Core. Poniższe punkty podsumowują przyjęty schemat i decyzje projektowe:
\begin{itemize}[noitemsep, topsep=0pt, leftmargin=*]
    \item \textbf{Workflows}: nazwa, bieżąca rewizja robocza (SET NULL po skasowaniu rewizji).
    \item \textbf{Revisions}: snapshot JSON, znacznik aktywności, kaskadowe powiązanie z workflow.
    \item \textbf{Executions}: wejście, wynik, ścieżka i logi w JSON; kaskadowo usuwane z workflow.
    \item \textbf{Blocks}: pozycja, konfiguracja JSON, FK do workflow (cascade) i SystemBlocks (restrict).
    \item \textbf{SystemBlocks}: 11 typów zasianych startowo (Start, End, HttpRequest, Parser, Calculation, If, Switch, Loop, Wait, TextTransform, TextReplace).
    \item \textbf{Connections}: źródło, cel, typ i etykieta; oba FK z \texttt{ON DELETE RESTRICT} dla uniknięcia cyklicznych kaskad.
    \item \textbf{Variables}: nazwa, domyślna wartość, FK do workflow (cascade).
    \item \textbf{Schedules}: interwał lub jednorazowy start, strefa czasowa, aktywność, opcjonalna przypięta rewizja (SET NULL po usunięciu), cascade do workflow.
    \item \textbf{Konfiguracje bloków}: trzymane jako JSON w \texttt{Blocks.JsonConfig} (HttpRequest, Parser, Calculation, Condition, Switch); dodawanie pól nie wymaga migracji SQL.
    \item \textbf{Enumy i indeksy}: enumy konwertowane do tekstu, migracje tworzą indeksy na wszystkich FK (m.in. \texttt{IX\_Blocks\_WorkflowId}, \texttt{IX\_BlockConnections\_SourceBlockId}, \texttt{IX\_WorkflowExecutions\_WorkflowId}).
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.6\linewidth,keepaspectratio]{img/er-db.png}
\caption{ERD bazy danych: Workflows, Revisions, Executions, Schedules, Variables, Blocks, SystemBlocks i BlockConnections z kardynalnościami}
\label{fig:er-db}
\end{figure}

\subsection{Ideowe przedstawienie interakcji}
\vspace{6pt}
\noindent
\indent W tej sekcji zestawiono diagramy ilustrujące przepływ informacji między warstwami Flowforge. Najpierw pokazano mapę komponentów (SPA, API, baza, scheduler, klient zewnętrzny), następnie trzy sekwencje zdarzeń: publikację i jednorazowe uruchomienie, obsługę harmonogramu oraz wywołanie zewnętrzne. Każdy rysunek prezentuje pełną ścieżkę żądania HTTP, zapis stanu w bazie i punkt, w którym powstają logi oraz ścieżka bloków, co ma znaczenie dla obserwowalności i audytu.

\begin{figure}[H]
\centering
\includegraphics[width=0.82\linewidth,keepaspectratio]{img/interactions.png}
\caption{Ideowe interakcje komponentów: SPA, API, baza SQLite/EF Core, scheduler i klient zewnętrzny}
\label{fig:interactions}
\end{figure}

\noindent
\indent Rysunek \ref{fig:interactions} pokazuje główne klocki: SPA i klient zewnętrzny korzystają z jednego kontraktu REST, API pośredniczy we wszystkich operacjach, a scheduler w tle wyzwala workflow na podstawie wpisów zapisanych w bazie SQLite/EF Core. Jeden punkt trwałości upraszcza audyt i obserwowalność, a brak bezpośrednich połączeń między klientami a schedulerem pozwala kontrolować uprawnienia wyłącznie na poziomie API.
\newpage

\begin{figure}[H]
\centering
\includegraphics[width=0.95\linewidth,keepaspectratio]{img/interactions-publish.png}
\caption{Publikacja wersji i jednorazowe wyzwolenie workflow z edytora}
\label{fig:interactions-publish}
\end{figure}

\noindent
\indent Rysunek \ref{fig:interactions-publish} pokazuje prostą sekwencję: POST /publish tworzy aktywną rewizję, a kolejne POST /run zakłada rekord wykonania, zwraca 202 i po zakończeniu dopisuje wynik, ścieżkę bloków i logi. Edytor przekazuje jedynie dane wejściowe i odbiera identyfikator – cała logika wykonania pozostaje w API, co ułatwia testy i gwarantuje powtarzalność uruchomień.

\newpage
\begin{figure}[H]
\centering
\includegraphics[width=0.95\linewidth,keepaspectratio]{img/interactions-schedule.png}
\caption{Obsługa harmonogramu przez usługę tła (polling, wyzwolenie, zapis wykonania)}
\label{fig:interactions-schedule}
\end{figure}


\noindent
\indent Rysunek \ref{fig:interactions-schedule} ilustruje planowane uruchomienie: UI zapisuje interwał, start i strefę czasową; scheduler cyklicznie pobiera aktywne wpisy, wywołuje workflow przez API, a wynik, ścieżka i logi trafiają do bazy. Parametry czasu przechowywane są w UTC, więc obsługa stref i zmiany czasu nie wymaga dodatkowej logiki.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\linewidth,keepaspectratio]{img/interactions-external.png}
\caption{Wywołanie endpointu workflow przez system zewnętrzny}
\label{fig:interactions-external}
\end{figure}

\noindent
\indent Rysunek \ref{fig:interactions-external} pokazuje integrację bez UI: klient zewnętrzny wywołuje endpoint, API tworzy rekord wykonania i zwraca 202; po przetworzeniu dopisuje wynik, ścieżkę i logi widoczne potem w Executions. Ten sam kontrakt HTTP obowiązuje UI i integratora, co ułatwia walidację i diagnozę.

\begin{thebibliography}{12}
\bibitem{n8n} Dokumentacja n8n. Dostęp: 9 lutego 2026. \url{https://n8n.io}
\bibitem{nodered} Projekt Node-RED. Dostęp: 9 lutego 2026. \url{https://nodered.org}
\bibitem{zapier} Zapier Platform Overview. Dostęp: 9 lutego 2026. \url{https://zapier.com}
\bibitem{powerautomate} Microsoft Power Automate. Dostęp: 9 lutego 2026. \url{https://powerautomate.microsoft.com}
\bibitem{spa} MDN Web Docs: Single-page application. Dostęp: 10 lutego 2026. \url{https://developer.mozilla.org/en-US/docs/Glossary/SPA}
\bibitem{kestrel} Microsoft Docs: Kestrel web server implementation in ASP.NET Core. Dostęp: 10 lutego 2026. \url{https://learn.microsoft.com/aspnet/core/fundamentals/servers/kestrel}
\bibitem{di} Microsoft Docs: Dependency injection in ASP.NET Core. Dostęp: 10 lutego 2026. \url{https://learn.microsoft.com/aspnet/core/fundamentals/dependency-injection}
\bibitem{react} React Documentation. Dostęp: 10 lutego 2026. \url{https://react.dev}
\bibitem{aspnetcore} ASP.NET Core documentation. Dostęp: 10 lutego 2026. \url{https://learn.microsoft.com/aspnet/core}
\bibitem{efcore} Entity Framework Core documentation. Dostęp: 10 lutego 2026. \url{https://learn.microsoft.com/ef/core}
\bibitem{sqlite} SQLite Documentation. Dostęp: 10 lutego 2026. \url{https://www.sqlite.org}
\end{thebibliography}

\end{document}
